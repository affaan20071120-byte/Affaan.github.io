<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scientific Calculator — Affaan (DEG/RAD, exact trig)</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --text:#e7e8ee; --muted:#b7bbd0;
    --card: rgba(255,255,255,0.05);
    --line: rgba(255,255,255,0.12);
    --bg1:#0b0f2a; --bg2:#2b0d3a;
    --gold:#ffd166;
  }
  *{ box-sizing:border-box }
  body{
    margin:0; min-height:100vh; color:var(--text); font-family:Poppins,system-ui,Arial;
    display:flex; align-items:center; justify-content:center; padding:20px;
    background: radial-gradient(1200px 800px at 20% 10%, rgba(255,60,80,0.10), transparent 60%),
                radial-gradient(1000px 700px at 80% 30%, rgba(58,160,255,0.12), transparent 60%),
                linear-gradient(180deg, var(--bg1), var(--bg2));
  }
  .wrap{
    width:min(520px,96vw);
    background:var(--card); border:1px solid var(--line); border-radius:16px; padding:18px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  }
  h1{ margin:6px 6px 12px; font-size:clamp(20px,3.2vw,28px) }
  p{ color:var(--muted); margin:8px 6px 12px; }
  .display{
    width:100%; border:1px solid var(--line); border-radius:12px; padding:12px; margin-bottom:12px;
    background: rgba(0,0,0,0.3); font-size:20px; color:var(--gold); text-align:right; min-height:56px;
    box-shadow: inset 0 0 18px rgba(58,160,255,0.08), 0 0 14px rgba(0,0,0,0.4);
    overflow-wrap:anywhere;
  }

  .controls{ display:flex; gap:8px; align-items:center; justify-content:flex-end; margin-bottom:8px; }
  .controls button{
    padding:8px 12px; border-radius:10px; border:1px solid var(--line); background:rgba(0,0,0,0.25);
    color:var(--gold); cursor:pointer; box-shadow: 0 0 12px var(--gold);
  }

  .grid{ display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; }
  button.key{
    padding:12px 10px; border-radius:12px; border:1px solid var(--line); background:rgba(0,0,0,0.25);
    color:var(--text); font-weight:600; cursor:pointer;
    box-shadow: 0 0 10px var(--gold), 0 0 14px rgba(255,255,255,0.06);
    transition: transform .12s ease, box-shadow .12s ease;
  }
  button.key:hover{ transform: translateY(-2px); box-shadow: 0 0 18px var(--gold); }
  .wide{ grid-column: span 2; }
  .equals{ grid-column: span 2; background: linear-gradient(90deg, rgba(255,210,102,0.06), rgba(255,210,102,0.02)); color:var(--gold); box-shadow: 0 0 14px var(--gold); }

  /* unit button static glow */
  #unitBtn{ grid-column: span 1; background: rgba(0,0,0,0.3); color:var(--gold); border:1px solid rgba(255,215,102,0.6); box-shadow: 0 0 12px rgba(255,210,102,0.85); }

  .hint{ color:var(--muted); font-size:13px; margin-top:8px; text-align:center; }
  code{ background: rgba(255,255,255,0.02); padding:2px 6px; border-radius:6px; color:var(--gold); }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Scientific calculator">
    <h1>Scientific Calculator</h1>
    <p>Type trig as <code>sin(30)</code> (DEG) or <code>sin(5pi/4)</code> (RAD). Use Mode to toggle DEG/RAD. Click unit button to insert unit.</p>

    <div id="display" class="display" aria-live="polite"></div>

    <div class="controls">
      <button id="modeToggle" type="button">Mode: <strong id="modeLabel">DEG</strong></button>
      <button id="unitBtn" type="button">°</button>
    </div>

    <div class="grid" id="keys" aria-hidden="false"></div>
    <div class="hint">Examples: <code>sin(30)</code> → <strong>1/2</strong>, <code>cos(5pi/4)</code> → <strong>-1/√2</strong></div>
  </div>

<script>
/* ---------------------------
   Keyboard / button layout
   --------------------------- */
const keyList = [
  '7','8','9','(',')',
  '4','5','6','^','√',
  '1','2','3','×','÷',
  '0','.','+','-','=',
  'sin','cos','tan','log','ln',
  'π','e','x²','1/x','%',
  'C','DEL','ANS','EXP','±'
];

const keysContainer = document.getElementById('keys');
function createKey(label){
  const b = document.createElement('button');
  b.type='button';
  b.className='key';
  b.textContent=label;
  if(label==='='||label==='C'||label==='DEL') b.classList.add('wide');
  if(label==='=') b.classList.add('equals');
  b.addEventListener('click', ()=>press(label));
  return b;
}
keyList.forEach(l => keysContainer.appendChild(createKey(l)));

const display = document.getElementById('display');
let memoryAns = 0;

/* ---------------------------
   Mode + Unit button logic
   --------------------------- */
let mode = 'deg'; // 'deg' or 'rad'
const modeLabel = document.getElementById('modeLabel');
const modeToggle = document.getElementById('modeToggle');
const unitBtn = document.getElementById('unitBtn');

modeToggle.addEventListener('click', ()=>{
  mode = (mode === 'deg') ? 'rad' : 'deg';
  modeLabel.textContent = mode.toUpperCase();
  unitBtn.textContent = (mode==='deg') ? '°' : 'rad';
});

unitBtn.addEventListener('click', ()=>{
  appendToDisplay((mode==='deg') ? '°' : 'rad');
});

/* append helper */
function appendToDisplay(txt){ display.textContent += txt; }

/* ---------------------------
   Trig exact lookup tables
   --------------------------- */
const trigExact = {
  deg: {
    0:  { sin:'0',   cos:'1',     tan:'0' },
    30: { sin:'1/2', cos:'√3/2',  tan:'1/√3' },
    45: { sin:'1/√2',cos:'1/√2',  tan:'1' },
    60: { sin:'√3/2',cos:'1/2',   tan:'√3' },
    90: { sin:'1',   cos:'0',     tan:'undefined' },
    120:{ sin:'√3/2',cos:'-1/2',  tan:'-√3' },
    135:{ sin:'1/√2',cos:'-1/√2', tan:'-1' },
    150:{ sin:'1/2', cos:'-√3/2', tan:'-1/√3' },
    180:{ sin:'0',   cos:'-1',    tan:'0' },
    210:{ sin:'-1/2',cos:'-√3/2', tan:'1/√3' },
    225:{ sin:'-1/√2',cos:'-1/√2',tan:'1' },
    240:{ sin:'-√3/2',cos:'-1/2', tan:'√3' },
    270:{ sin:'-1',  cos:'0',     tan:'undefined' },
    300:{ sin:'-√3/2',cos:'1/2',  tan:'-√3' },
    315:{ sin:'-1/√2',cos:'1/√2', tan:'-1' },
    330:{ sin:'-1/2',cos:'√3/2',  tan:'-1/√3' },
    360:{ sin:'0',   cos:'1',     tan:'0' }
  },
  rad: {
    '0':   { sin:'0',   cos:'1',     tan:'0' },
    'π/6': { sin:'1/2', cos:'√3/2',  tan:'1/√3' },
    'π/4': { sin:'1/√2',cos:'1/√2',  tan:'1' },
    'π/3': { sin:'√3/2',cos:'1/2',   tan:'√3' },
    'π/2': { sin:'1',   cos:'0',     tan:'undefined' },
    '2π/3':{ sin:'√3/2',cos:'-1/2',  tan:'-√3' },
    '3π/4':{ sin:'1/√2',cos:'-1/√2', tan:'-1' },
    '5π/6':{ sin:'1/2', cos:'-√3/2', tan:'-1/√3' },
    'π':   { sin:'0',   cos:'-1',    tan:'0' },
    '7π/6':{ sin:'-1/2',cos:'-√3/2', tan:'1/√3' },
    '5π/4':{ sin:'-1/√2',cos:'-1/√2',tan:'1' },
    '4π/3':{ sin:'-√3/2',cos:'-1/2', tan:'√3' },
    '3π/2':{ sin:'-1',  cos:'0',     tan:'undefined' },
    '5π/3':{ sin:'-√3/2',cos:'1/2',  tan:'-√3' },
    '7π/4':{ sin:'-1/√2',cos:'1/√2', tan:'-1' },
    '11π/6':{sin:'-1/2', cos:'√3/2', tan:'-1/√3' },
    '2π':  { sin:'0',   cos:'1',     tan:'0' }
  }
};

/* Utility: nearly equal */
function nearlyEqual(a,b,eps=1e-12){ return Math.abs(a-b) <= eps; }

/* Rational approx for fraction of pi */
function rationalApprox(x, maxDen=48, tol=1e-10){
  // try denominators up to maxDen
  for(let d=1; d<=maxDen; d++){
    const n = Math.round(x * d);
    if(nearlyEqual(x, n/d, tol)) return {n, d};
  }
  return null;
}

/* canonicalize radian expression: accepts forms like:
   π/4, 3π/2, 5pi/4, 6pi/4, -pi/4, 3*π/2, (3*pi)/2, numeric combos.
   returns canonical key like 'π/4', '5π/4', '0', 'π', '3π/2', or null if cannot canonicalize
*/
function canonicalizeRadicalPi(expr){
  // normalize input string
  if(typeof expr !== 'string') expr = String(expr);
  let s = expr.replace(/\s+/g,''); // remove whitespace
  s = s.replace(/PI/ig, 'π'); // accept 'pi' or 'PI'
  // direct quick patterns: if contains 'π'
  if(/π/.test(s)){
    try {
      // replace '*' with nothing for easier parsing like '3*π/4' => '3π/4'
      s = s.replace(/\*/g,'');
      // handle leading + sign
      // split into numerator/denominator around '/'
      let sign = 1;
      if(s[0]==='-'){ sign=-1; s = s.slice(1); }
      // count occurrences of π
      // turn  'π' -> '1π' if leading, '3π' stays '3π'
      s = s.replace(/^π/, '1π').replace(/([^\d])π/, '$11π'); // ensure some forms covered
      // Now try to parse pattern like 'nπ/d' or 'nπ' or 'π/d'
      const m = s.match(/^(-?\d+)?π(?:\/(-?\d+))?$/i) || s.match(/^(-?\d+)\(π\)\/?(-?\d+)?$/i);
      if(m){
        let n = (m[1] === undefined || m[1]==='') ? 1 : Number(m[1]);
        let d = (m[2] === undefined) ? 1 : Number(m[2]);
        n = n * sign;
        // reduce fraction
        const gcd = (a,b)=>b?gcd(b,a%b):Math.abs(a);
        const g = gcd(n,d) || 1;
        n = n/g; d = d/g;
        // normalize to [0,2π)
        let frac = n/d;
        frac = ((frac % 2) + 2) % 2;
        // approximate frac with small denominator
        const approx = rationalApprox(frac, 48, 1e-10);
        if(!approx) return null;
        let N = approx.n, D = approx.d;
        if(N===0) return '0';
        if(N===D) return 'π';
        // format nicely (positive numerator)
        return (N===1? 'π' : (N+'π')) + (D===1? '' : ('/'+D));
      }
    } catch(e){
      return null;
    }
  } else {
    // no π symbol: try numeric evaluation and check ratio to π
    try {
      const js = expr.replace(/\^/g,'**').replace(/√\(/g,'Math.sqrt(').replace(/π/g,'Math.PI').replace(/pi/ig,'Math.PI');
      const val = Function('return (' + js + ')')();
      if(!isFinite(val)) return null;
      const frac = val / Math.PI;
      const approx = rationalApprox(frac, 48, 1e-10);
      if(!approx) return null;
      let {n,d} = approx;
      // normalize into [0,2)
      n = ((n % (2*d)) + 2*d) % (2*d);
      if(n===0) return '0';
      if(n===d) return 'π';
      // reduce
      const gcd = (a,b)=>b?gcd(b,a%b):Math.abs(a);
      const g = gcd(n,d) || 1;
      n/=g; d/=g;
      return (n===1? 'π' : (n+'π')) + (d===1? '' : ('/'+d));
    } catch(e){
      return null;
    }
  }
  return null;
}

/* Try exact symbolic trig if input is a single trig call like sin(...), cos(...), tan(...) */
function tryExactTrigSingle(text){
  text = text.trim();
  const m = text.match(/^\s*(sin|cos|tan)\((.+)\)\s*$/i);
  if(!m) return {found:false};
  const fn = m[1].toLowerCase();
  let argRaw = m[2].trim();

  // detect explicit unit markers
  const hasDegreeSymbol = /°/.test(argRaw);
  const hasRadToken = /\brad\b/.test(argRaw);
  const hasPi = /π|pi/i.test(argRaw);

  // determine unit: explicit symbols override mode
  let unit = mode;
  if(hasDegreeSymbol) unit = 'deg';
  else if(hasRadToken || hasPi) unit = 'rad';

  // evaluate accordingly
  if(unit === 'deg'){
    // strip degree symbol
    argRaw = argRaw.replace(/°/g,'');
    // try numeric evaluation (can be decimal)
    let degVal;
    try {
      const js = argRaw.replace(/\^/g,'**').replace(/√\(/g,'Math.sqrt(').replace(/π/g,'Math.PI').replace(/pi/ig,'Math.PI');
      degVal = Function('return (' + js + ')')();
    } catch(e){
      return {found:false};
    }
    if(!isFinite(degVal)) return {found:false};
    // normalize to [0,360)
    let degNorm = ((degVal % 360) + 360) % 360;
    // if it's very near integer, snap to integer to catch angles like 30.0000000001
    const rounded = Math.round(degNorm);
    if(nearlyEqual(degNorm, rounded, 1e-10)) degNorm = rounded;
    // check in map
    if(trigExact.deg.hasOwnProperty(degNorm)){
      return {found:true, value: trigExact.deg[degNorm][fn]};
    }
    return {found:false};
  } else {
    // RAD: canonicalize the argument into canonical pi-fraction key
    const key = canonicalizeRadicalPi(argRaw);
    if(key && trigExact.rad.hasOwnProperty(key)){
      return {found:true, value: trigExact.rad[key][fn]};
    }
    return {found:false};
  }
}

/* Convert user expression into JS expression for numeric eval
   - converts N° into (N*Math.PI/180)
   - replaces π/pi with Math.PI
   - handles √( and ^, log ln
   - uses mode: when mode===deg and trig functions used without explicit unit, convert angle to radians
*/
function toJS(expr){
  if(typeof expr !== 'string') expr = String(expr);
  // replace degree tokens like 30° -> (30*Math.PI/180)
  expr = expr.replace(/([0-9]+(?:\.[0-9]+)?)\s*°/g, '($1*Math.PI/180)');
  // textual deg
  expr = expr.replace(/\bdeg\b/g, '*Math.PI/180');

  // replace pi symbols/words
  expr = expr.replace(/π/g, 'Math.PI').replace(/\bpi\b/ig, 'Math.PI');

  // sqrt
  expr = expr.replace(/√\(/g, 'Math.sqrt(');

  // ^ -> **
  expr = expr.replace(/\^/g, '**');

  // strip explicit 'rad' token (no-op)
  expr = expr.replace(/\brad\b/g, '');

  // trig handling: if mode is deg and trig functions are present, wrap argument with *PI/180
  if(mode === 'deg'){
    expr = expr.replace(/sin\(([^)]+)\)/g, 'Math.sin(($1)*Math.PI/180)');
    expr = expr.replace(/cos\(([^)]+)\)/g, 'Math.cos(($1)*Math.PI/180)');
    expr = expr.replace(/tan\(([^)]+)\)/g, 'Math.tan(($1)*Math.PI/180)');
  } else {
    expr = expr.replace(/sin\(/g, 'Math.sin(');
    expr = expr.replace(/cos\(/g, 'Math.cos(');
    expr = expr.replace(/tan\(/g, 'Math.tan(');
  }

  expr = expr.replace(/log\(/g, 'Math.log10(');
  expr = expr.replace(/ln\(/g, 'Math.log(');

  return expr;
}

/* Format numeric results cleanly */
function formatNumber(n){
  if(!isFinite(n)) return String(n);
  // use 12 significant digits, then trim trailing zeros
  const s = Number(n).toPrecision(12);
  if(/[eE]/.test(s)) return s;
  return parseFloat(s).toString();
}

/* Evaluate and display */
function evaluate(){
  const txt = display.textContent.trim();
  if(!txt) return;

  // 1) Try exact symbolic single trig
  const exact = tryExactTrigSingle(txt);
  if(exact.found){
    display.textContent = exact.value;
    memoryAns = exact.value;
    return;
  }

  // 2) Fallback numeric evaluation
  try {
    const js = toJS(txt);
    const val = Function('return (' + js + ')')();
    if(typeof val === 'number') {
      display.textContent = formatNumber(val);
      memoryAns = val;
    } else {
      display.textContent = String(val);
      memoryAns = val;
    }
  } catch(e){
    display.textContent = 'Error';
  }
}

/* Button behaviors */
function press(key){
  if(key === 'C'){ display.textContent = ''; return; }
  if(key === 'DEL'){ display.textContent = display.textContent.slice(0,-1); return; }
  if(key === 'ANS'){ display.textContent += String(memoryAns); return; }
  if(key === 'π'){ display.textContent += 'π'; return; }
  if(key === 'e'){ display.textContent += 'e'; return; }
  if(key === 'x²'){ display.textContent += '^2'; return; }
  if(key === '1/x'){ display.textContent += '^-1'; return; }
  if(key === 'EXP'){ display.textContent += 'e^'; return; }
  if(key === '±'){ toggleSign(); return; }
  if(['sin','cos','tan','log','ln','√'].includes(key)){
    if(key === '√') display.textContent += '√(';
    else display.textContent += key + '(';
    return;
  }
  if(key === '×'){ display.textContent += '*'; return; }
  if(key === '÷'){ display.textContent += '/'; return; }
  if(key === '='){ evaluate(); return; }
  display.textContent += key;
}

function toggleSign(){
  const s = display.textContent;
  const m = s.match(/(-?\d*\.?\d+)(?!.*\d)/);
  if (!m) { display.textContent += '-'; return; }
  const start = m.index; const end = start + m[0].length;
  const before = s.slice(0,start);
  const num = m[0];
  const after = s.slice(end);
  const toggled = num.startsWith('-') ? num.slice(1) : '-' + num;
  display.textContent = before + toggled + after;
}

/* Keyboard support */
document.addEventListener('keydown',(e)=>{
  const k = e.key;
  if((k>='0' && k<='9') || k==='.' || k==='+' || k==='-' || k==='*' || k==='/' || k==='(' || k===')' || k==='%'){
    display.textContent += k;
    e.preventDefault();
  } else if(k==='Enter'){ evaluate(); e.preventDefault(); }
  else if(k==='Backspace'){ display.textContent = display.textContent.slice(0,-1); e.preventDefault(); }
});

/* initialize */
document.getElementById('modeToggle').addEventListener('click', ()=>{ mode = (mode==='deg') ? 'rad' : 'deg'; modeLabel.textContent = mode.toUpperCase(); unitBtn.textContent = (mode==='deg') ? '°' : 'rad'; });
keysContainer.querySelectorAll('button.key').forEach(b=>{
  // already wired with click handlers in createKey
});
/* done */
</script>
</body>
</html>
